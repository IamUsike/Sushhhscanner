"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterVulnerabilityScanner = void 0;
const parameterTester_1 = require("./parameterTester");
const aiPayloadGenerator_1 = require("./aiPayloadGenerator");
const logger_1 = require("../utils/logger");
class ParameterVulnerabilityScanner {
    constructor(options = {}) {
        // Set defaults
        this.options = {
            concurrency: 3,
            timeoutPerParameter: 30000,
            skipParameters: [],
            targetSeverity: 'ALL',
            enableSmartTesting: true,
            adaptiveTesting: true,
            useAI: true,
            maxPayloads: 50,
            includeAdvanced: true,
            ...options
        };
        this.parameterTester = new parameterTester_1.ParameterTester(this.options);
        this.aiPayloadGenerator = new aiPayloadGenerator_1.AIPayloadGenerator();
        this.scanId = `param_scan_${Date.now()}`;
    }
    async scanEndpoint(endpointParam, progressCallback) {
        const scanStartTime = new Date().toISOString();
        logger_1.logger.info(`Starting parameter vulnerability scan for: ${endpointParam.method} ${endpointParam.endpoint}`);
        if (progressCallback) {
            progressCallback(`🔍 Starting parameter scan for ${endpointParam.endpoint}...`);
        }
        try {
            const vulnerabilities = [];
            let totalPayloadsGenerated = 0;
            let aiEnhancedPayloads = 0;
            const parameterTestTimes = [];
            // Filter parameters to test
            const parametersToTest = endpointParam.parameters.filter(param => !this.options.skipParameters?.includes(param.name));
            if (progressCallback) {
                progressCallback(`📋 Testing ${parametersToTest.length} parameters...`);
            }
            // Test each parameter
            for (let i = 0; i < parametersToTest.length; i++) {
                const parameter = parametersToTest[i];
                const paramStartTime = Date.now();
                if (progressCallback) {
                    progressCallback(`🧪 Testing parameter ${i + 1}/${parametersToTest.length}: ${parameter.name}`);
                }
                try {
                    // Create payload context for AI enhancement
                    const context = {
                        parameterName: parameter.name,
                        parameterType: parameter.type,
                        endpoint: endpointParam.endpoint,
                        method: endpointParam.method,
                        applicationContext: await this.detectApplicationContext(endpointParam.endpoint),
                        previousFindings: this.getPreviousFindings(parameter.name)
                    };
                    // Generate AI-enhanced payloads if enabled
                    let enhancedPayloads = [];
                    if (this.options.useAI) {
                        const aiPayloads = await this.aiPayloadGenerator.generatePayloads(parameter, context);
                        enhancedPayloads = aiPayloads;
                        totalPayloadsGenerated += aiPayloads.length;
                        aiEnhancedPayloads += aiPayloads.filter(p => p.source === 'ai_generated' || p.source === 'ml_enhanced').length;
                    }
                    // Test parameter with enhanced payloads
                    const paramVulns = await this.parameterTester.testParameter(endpointParam.endpoint, endpointParam.method, parameter);
                    vulnerabilities.push(...paramVulns);
                    const testTime = Date.now() - paramStartTime;
                    parameterTestTimes.push(testTime);
                    if (progressCallback && paramVulns.length > 0) {
                        progressCallback(`🚨 Found ${paramVulns.length} vulnerabilities in ${parameter.name}`);
                    }
                    // Adaptive testing: adjust strategy based on findings
                    if (this.options.adaptiveTesting && paramVulns.length > 0) {
                        await this.adaptTestingStrategy(paramVulns);
                    }
                }
                catch (error) {
                    logger_1.logger.warn(`Parameter testing failed for ${parameter.name}: ${error.message}`);
                }
            }
            const scanEndTime = new Date().toISOString();
            if (progressCallback) {
                progressCallback(`✅ Parameter scan completed. Found ${vulnerabilities.length} vulnerabilities.`);
            }
            // Generate scan result
            const result = this.generateScanResult(endpointParam, scanStartTime, scanEndTime, vulnerabilities, parameterTestTimes, totalPayloadsGenerated, aiEnhancedPayloads);
            return result;
        }
        catch (error) {
            logger_1.logger.error(`Parameter vulnerability scan failed: ${error.message}`);
            throw error;
        }
    }
    async scanMultipleEndpoints(endpoints, progressCallback) {
        const overallStartTime = Date.now();
        logger_1.logger.info(`Starting comprehensive parameter scan for ${endpoints.length} endpoints`);
        if (progressCallback) {
            progressCallback(`🚀 Starting comprehensive parameter scan for ${endpoints.length} endpoints...`);
        }
        try {
            const results = [];
            // Process endpoints with concurrency control
            for (let i = 0; i < endpoints.length; i += (this.options.concurrency || 3)) {
                const batch = endpoints.slice(i, i + (this.options.concurrency || 3));
                if (progressCallback) {
                    progressCallback(`🔄 Processing endpoint batch ${Math.floor(i / (this.options.concurrency || 3)) + 1}...`);
                }
                const batchPromises = batch.map(endpoint => this.scanEndpoint(endpoint, progressCallback));
                const batchResults = await Promise.allSettled(batchPromises);
                batchResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        results.push(result.value);
                    }
                    else {
                        logger_1.logger.error(`Endpoint scan failed for ${batch[index].endpoint}: ${result.reason}`);
                    }
                });
            }
            const scanDuration = Date.now() - overallStartTime;
            if (progressCallback) {
                progressCallback(`📊 Generating comprehensive report...`);
            }
            // Generate comprehensive report
            const report = this.generateComprehensiveReport(results, scanDuration);
            if (progressCallback) {
                progressCallback(`🎉 Comprehensive parameter scan completed!`);
            }
            return report;
        }
        catch (error) {
            logger_1.logger.error(`Comprehensive parameter scan failed: ${error.message}`);
            throw error;
        }
    }
    async detectApplicationContext(endpoint) {
        // Simple application context detection
        // In a real implementation, this would be more sophisticated
        const context = {};
        try {
            // Framework detection based on endpoint patterns
            if (endpoint.includes('/api/v')) {
                context.framework = 'express'; // Common REST API pattern
            }
            else if (endpoint.includes('/graphql')) {
                context.framework = 'graphql';
            }
            else if (endpoint.includes('.php')) {
                context.framework = 'php';
            }
            // Database detection (simplified)
            if (endpoint.includes('mongo') || endpoint.includes('nosql')) {
                context.database = 'mongodb';
            }
            else if (endpoint.includes('postgres') || endpoint.includes('pg')) {
                context.database = 'postgresql';
            }
            else {
                context.database = 'mysql'; // Default assumption
            }
            return context;
        }
        catch (error) {
            return {};
        }
    }
    getPreviousFindings(parameterName) {
        // In a real implementation, this would fetch from a database or cache
        // Simulated previous findings for AI enhancement
        return [
            { type: 'sql_injection', parameter: 'id', success: true },
            { type: 'xss', parameter: 'search', success: true },
            { type: 'command_injection', parameter: 'cmd', success: false }
        ];
    }
    async adaptTestingStrategy(vulnerabilities) {
        // Adaptive testing strategy based on discovered vulnerabilities
        const vulnTypes = vulnerabilities.map(v => v.vulnerability.type);
        if (vulnTypes.includes('sql_injection')) {
            // If SQL injection found, increase focus on database-related tests
            this.options.maxPayloads = Math.min((this.options.maxPayloads || 50) + 20, 100);
            logger_1.logger.info('SQL injection detected - adapting strategy to focus on database attacks');
        }
        if (vulnTypes.includes('xss')) {
            // If XSS found, focus on client-side injection tests
            this.options.includeAdvanced = true;
            logger_1.logger.info('XSS detected - enabling advanced client-side injection tests');
        }
        // Adjust timeout based on response patterns
        const hasTimingVulns = vulnerabilities.some(v => v.evidence.responseTime > 3000);
        if (hasTimingVulns) {
            this.options.timeoutPerParameter = Math.max((this.options.timeoutPerParameter || 30000) + 10000, 60000);
            logger_1.logger.info('Timing anomalies detected - increasing timeout for comprehensive testing');
        }
    }
    generateScanResult(endpointParam, scanStartTime, scanEndTime, vulnerabilities, testTimes, payloadsGenerated, aiEnhancedPayloads) {
        // Group vulnerabilities by parameter
        const byParameter = {};
        vulnerabilities.forEach(vuln => {
            byParameter[vuln.parameter.name] = (byParameter[vuln.parameter.name] || 0) + 1;
        });
        // Group by severity
        const bySeverity = {};
        vulnerabilities.forEach(vuln => {
            bySeverity[vuln.vulnerability.severity] = (bySeverity[vuln.vulnerability.severity] || 0) + 1;
        });
        // Group by technique
        const byTechnique = {};
        vulnerabilities.forEach(vuln => {
            byTechnique[vuln.vulnerability.type] = (byTechnique[vuln.vulnerability.type] || 0) + 1;
        });
        // Calculate risk score
        const riskScore = this.calculateRiskScore(vulnerabilities);
        // Generate recommendations
        const recommendations = this.generateRecommendations(vulnerabilities);
        return {
            endpoint: endpointParam.endpoint,
            method: endpointParam.method,
            scanStartTime,
            scanEndTime,
            totalParametersTested: endpointParam.parameters.length,
            vulnerabilitiesFound: vulnerabilities.length,
            vulnerabilities,
            scanSummary: {
                byParameter,
                bySeverity,
                byTechnique,
                averageTestTime: testTimes.reduce((a, b) => a + b, 0) / testTimes.length || 0,
                payloadsGenerated,
                aiEnhancedPayloads
            },
            recommendations,
            riskScore
        };
    }
    generateComprehensiveReport(results, scanDuration) {
        const allVulnerabilities = results.flatMap(r => r.vulnerabilities);
        const totalParametersTested = results.reduce((sum, r) => sum + r.totalParametersTested, 0);
        // Calculate overall risk score
        const overallRiskScore = this.calculateOverallRiskScore(results);
        // Get top vulnerabilities
        const topVulnerabilities = this.getTopVulnerabilities(allVulnerabilities);
        // Generate remediation priorities
        const remediationPriority = this.generateRemediationPriorities(allVulnerabilities);
        // Generate executive summary
        const executiveSummary = this.generateExecutiveSummary(results, allVulnerabilities);
        return {
            scanId: this.scanId,
            targetCount: results.length,
            totalVulnerabilities: allVulnerabilities.length,
            totalParametersTested,
            scanDuration,
            overallRiskScore,
            results,
            executiveSummary,
            topVulnerabilities,
            remediationPriority
        };
    }
    calculateRiskScore(vulnerabilities) {
        if (vulnerabilities.length === 0)
            return 0;
        const severityWeights = { CRITICAL: 10, HIGH: 7, MEDIUM: 4, LOW: 1 };
        const totalWeight = vulnerabilities.reduce((sum, vuln) => {
            return sum + severityWeights[vuln.vulnerability.severity];
        }, 0);
        // Normalize to 0-100 scale
        const maxPossibleScore = vulnerabilities.length * 10;
        return Math.min(Math.round((totalWeight / maxPossibleScore) * 100), 100);
    }
    calculateOverallRiskScore(results) {
        if (results.length === 0)
            return 0;
        const totalScore = results.reduce((sum, result) => sum + result.riskScore, 0);
        return Math.round(totalScore / results.length);
    }
    generateRecommendations(vulnerabilities) {
        const recommendations = [];
        const vulnTypes = [...new Set(vulnerabilities.map(v => v.vulnerability.type))];
        if (vulnTypes.includes('sql_injection')) {
            recommendations.push('🛡️ Implement parameterized queries and input validation for all database interactions');
        }
        if (vulnTypes.includes('xss')) {
            recommendations.push('🔒 Implement output encoding and Content Security Policy (CSP) headers');
        }
        if (vulnTypes.includes('command_injection')) {
            recommendations.push('⚠️ Avoid system command execution; use safe APIs and comprehensive input validation');
        }
        if (vulnTypes.includes('nosql_injection')) {
            recommendations.push('🔍 Implement strict schema validation and query sanitization for NoSQL databases');
        }
        if (recommendations.length === 0) {
            recommendations.push('✅ Continue monitoring and implement additional security hardening measures');
        }
        return recommendations;
    }
    getTopVulnerabilities(vulnerabilities) {
        const severityOrder = { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 };
        return vulnerabilities
            .sort((a, b) => {
            // Sort by severity first, then by confidence
            const severityDiff = severityOrder[b.vulnerability.severity] - severityOrder[a.vulnerability.severity];
            if (severityDiff !== 0)
                return severityDiff;
            return b.vulnerability.confidence - a.vulnerability.confidence;
        })
            .slice(0, 10);
    }
    generateRemediationPriorities(vulnerabilities) {
        return vulnerabilities.map(vuln => {
            let priority;
            let estimatedEffort;
            switch (vuln.vulnerability.severity) {
                case 'CRITICAL':
                    priority = 'URGENT';
                    estimatedEffort = '1-2 days';
                    break;
                case 'HIGH':
                    priority = 'HIGH';
                    estimatedEffort = '3-5 days';
                    break;
                case 'MEDIUM':
                    priority = 'MEDIUM';
                    estimatedEffort = '1-2 weeks';
                    break;
                default:
                    priority = 'LOW';
                    estimatedEffort = '2-4 weeks';
            }
            return {
                vulnerability: vuln,
                priority,
                estimatedEffort
            };
        }).slice(0, 20); // Limit to top 20 for manageable remediation planning
    }
    generateExecutiveSummary(results, vulnerabilities) {
        const criticalCount = vulnerabilities.filter(v => v.vulnerability.severity === 'CRITICAL').length;
        const highCount = vulnerabilities.filter(v => v.vulnerability.severity === 'HIGH').length;
        const totalEndpoints = results.length;
        const averageRisk = results.reduce((sum, r) => sum + r.riskScore, 0) / results.length;
        let summary = `Parameter vulnerability assessment of ${totalEndpoints} API endpoints identified ${vulnerabilities.length} potential security issues. `;
        if (criticalCount > 0) {
            summary += `${criticalCount} CRITICAL vulnerabilities require immediate attention. `;
        }
        if (highCount > 0) {
            summary += `${highCount} HIGH severity vulnerabilities should be addressed promptly. `;
        }
        summary += `The overall risk level is ${averageRisk >= 70 ? 'HIGH' : averageRisk >= 40 ? 'MEDIUM' : 'LOW'} with an average risk score of ${Math.round(averageRisk)}. `;
        const topTypes = this.getTopVulnerabilityTypes(vulnerabilities);
        if (topTypes.length > 0) {
            summary += `Primary vulnerability types include: ${topTypes.join(', ')}.`;
        }
        return summary;
    }
    getTopVulnerabilityTypes(vulnerabilities) {
        const typeCounts = {};
        vulnerabilities.forEach(vuln => {
            typeCounts[vuln.vulnerability.type] = (typeCounts[vuln.vulnerability.type] || 0) + 1;
        });
        return Object.entries(typeCounts)
            .sort(([, a], [, b]) => b - a)
            .slice(0, 3)
            .map(([type, count]) => `${type.replace(/_/g, ' ')} (${count})`);
    }
}
exports.ParameterVulnerabilityScanner = ParameterVulnerabilityScanner;
//# sourceMappingURL=parameterVulnerabilityScanner.js.map